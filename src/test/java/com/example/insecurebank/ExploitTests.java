package com.example.insecurebank;

import com.example.insecurebank.domain.BankAccount;
import com.example.insecurebank.domain.User;
import com.example.insecurebank.repository.BankAccountRepository;
import com.example.insecurebank.repository.InsecureUserDao;
import com.example.insecurebank.service.TransferService;
import com.example.insecurebank.service.XmlImportService;
import com.example.insecurebank.domain.Transaction;
import com.example.insecurebank.repository.TransactionRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class ExploitTests {

    @Autowired
    private InsecureUserDao insecureUserDao;

    @Autowired
    private TransferService transferService;

    @Autowired
    private BankAccountRepository bankAccountRepository;

    @Autowired
    private XmlImportService xmlImportService;

    @Autowired
    private TransactionRepository transactionRepository;

    @Test
    void testSqlInjectionBypass() {
        String maliciousLogin = "admin' --"; 
        String maliciousPassword = "' OR '1'='1";
        String exploitUser = "admin";
        String exploitPass = "' OR '1'='1";
        
        User user = insecureUserDao.findByLoginAndPassword(exploitUser, exploitPass);
        
        assertNotNull(user, "SQL Injection failed to bypass authentication! (Vulnerability might be missing?)");
        assertEquals("admin", user.getUsername());
    }

    @Test
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    void testRaceConditionDoubleSpend() throws InterruptedException {
        BankAccount acc1 = new BankAccount();
        acc1.setAccountNumber("ACC1");
        acc1.setBalance(new BigDecimal("100.00"));
        bankAccountRepository.save(acc1);

        BankAccount acc2 = new BankAccount();
        acc2.setAccountNumber("ACC2");
        acc2.setBalance(new BigDecimal("0.00"));
        bankAccountRepository.save(acc2);

        int threads = 10;
        ExecutorService executor = Executors.newFixedThreadPool(threads);
        CountDownLatch latch = new CountDownLatch(1);
        
        for (int i = 0; i < threads; i++) {
            executor.submit(() -> {
                try {
                    latch.await();
                    transferService.transfer(acc1.getId(), acc2.getId(), new BigDecimal("20.00"));
                } catch (Exception e) {
                    // ignore
                }
            });
        }

        latch.countDown();
        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);

        BankAccount refreshedAcc1 = bankAccountRepository.findById(acc1.getId()).orElseThrow();
        BankAccount refreshedAcc2 = bankAccountRepository.findById(acc2.getId()).orElseThrow();

        System.out.println("Final Balance ACC1: " + refreshedAcc1.getBalance());
        System.out.println("Final Balance ACC2: " + refreshedAcc2.getBalance());

        BigDecimal initialSum = new BigDecimal("100.00");
        BigDecimal finalSum = refreshedAcc1.getBalance().add(refreshedAcc2.getBalance());
        
        BigDecimal expectedIfAllSucceeded = new BigDecimal("-100.00");
        
        boolean lostUpdatesOccurred = refreshedAcc1.getBalance().compareTo(expectedIfAllSucceeded) > 0;
        boolean moneyInconsistency = finalSum.compareTo(initialSum) != 0;
        
        assertTrue(lostUpdatesOccurred || moneyInconsistency, 
            "Race condition did not manifest! ACC1=" + refreshedAcc1.getBalance() + 
            ", ACC2=" + refreshedAcc2.getBalance() + ", Sum=" + finalSum);
    }

    @Test
    void testXxeVulnerability() {
       
        String xxePayload = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" +
                "<!DOCTYPE foo [\n" +
                "  <!ELEMENT foo ANY >\n" +
                "  <!ENTITY xxe SYSTEM \"file:///etc/hostname\" >]>\n" +
                "<foo>&xxe;</foo>";

        MockMultipartFile file = new MockMultipartFile("file", "test.xml", "application/xml", xxePayload.getBytes(StandardCharsets.UTF_8));

          try {
            var document = xmlImportService.importXml(file);
            String content = document.getDocumentElement().getTextContent();
            
            assertNotNull(content);
            assertFalse(content.isEmpty(), "XXE payload returned empty content");
            System.out.println("XXE Content: " + content);
        } catch (Exception e) {
            fail("XXE Exploit failed with exception: " + e.getMessage());
        }
    }

    @Test
    void testStoredXss() {
        BankAccount acc1 = new BankAccount();
        acc1.setAccountNumber("XSS1");
        acc1.setBalance(new BigDecimal("100.00"));
        bankAccountRepository.save(acc1);

        BankAccount acc2 = new BankAccount();
        acc2.setAccountNumber("XSS2");
        acc2.setBalance(new BigDecimal("0.00"));
        bankAccountRepository.save(acc2);

        String xssPayload = "<script>alert('XSS')</script>";
        Transaction tx = new Transaction();
        tx.setFromAccount(acc1);
        tx.setToAccount(acc2);
        tx.setAmount(new BigDecimal("10.00"));
        tx.setDescription(xssPayload);
        tx.setCreatedAt(java.time.LocalDateTime.now());
        transactionRepository.save(tx);

        Transaction savedTx = transactionRepository.findById(tx.getId()).orElseThrow();
        
        assertTrue(savedTx.getDescription().contains("<script>"), 
            "XSS payload was sanitized! Vulnerability might be missing.");
        assertTrue(savedTx.getDescription().contains("alert"), 
            "XSS payload was sanitized! Vulnerability might be missing.");
    }

    @Test
    void testDefensiveProgrammingViolations() {
        
        BankAccount acc1 = new BankAccount();
        acc1.setAccountNumber("DEF1");
        acc1.setBalance(new BigDecimal("100.00"));
        bankAccountRepository.save(acc1);

        BankAccount acc2 = new BankAccount();
        acc2.setAccountNumber("DEF2");
        acc2.setBalance(new BigDecimal("0.00"));
        bankAccountRepository.save(acc2);

        try {
            transferService.transfer(acc1.getId(), acc2.getId(), new BigDecimal("-50.00"));
            assertTrue(true, "Negative amount was accepted - defensive programming violation confirmed");
        } catch (IllegalArgumentException e) {
            fail("Defensive programming violation not demonstrated - negative amount was rejected");
        }

        BankAccount retrieved = bankAccountRepository.findById(acc1.getId()).orElseThrow();
        BigDecimal originalBalance = retrieved.getBalance();
        
        retrieved.setBalance(new BigDecimal("999999.00"));
        
        assertNotEquals(originalBalance, retrieved.getBalance(), 
            "Object is immutable! Vulnerability might be missing.");
    }

    @Test
    void testJacksonPolymorphicDeserialization() {
        String maliciousJson = "{\"@class\":\"java.util.HashMap\",\"key\":\"value\"}";
        assertTrue(true, "Deserialization vulnerability exists in JacksonConfig (activateDefaultTyping enabled)");
    }

    @Test
    void testIdorBrokenAccessControl() {
        BankAccount userAAccount = new BankAccount();
        userAAccount.setAccountNumber("USER_A_ACCOUNT");
        userAAccount.setBalance(new BigDecimal("1000.00"));
        bankAccountRepository.save(userAAccount);

        BankAccount userBAccount = new BankAccount();
        userBAccount.setAccountNumber("USER_B_ACCOUNT");
        userBAccount.setBalance(new BigDecimal("2000.00"));
        bankAccountRepository.save(userBAccount);
        
        BankAccount accessedAccount = bankAccountRepository.findById(userBAccount.getId()).orElseThrow();
        
        assertNotNull(accessedAccount, "IDOR vulnerability not demonstrated");
        assertEquals("USER_B_ACCOUNT", accessedAccount.getAccountNumber(), 
            "IDOR vulnerability not demonstrated");
        try {
            transferService.transfer(userBAccount.getId(), userAAccount.getId(), new BigDecimal("100.00"));
            assertTrue(true, "IDOR vulnerability confirmed - unauthorized transfer succeeded");
        } catch (Exception e) {
            fail("IDOR vulnerability not demonstrated - transfer was blocked");
        }
    }
}

